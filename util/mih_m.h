//
// Generated file, do not edit! Created by nedtool 5.7 from util/mih.msg.
//

#ifndef __MIH_M_H
#define __MIH_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0507
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
//#include "ipv6.h"
#include "C:\Users\ronaa\Downloads\numbat-master (2)\numbat-master\numbat-master\xMIPv6\src\networklayer\contract\IPv6Address.h"	//Adam
// }}

/**
 * Class generated from <tt>util/mih.msg:16</tt> by nedtool.
 * <pre>
 * //message -> packet changes (MiM)
 * // used to report that L2 entry started
 * packet MihEvent_EntryStart
 * {
 * }
 * </pre>
 */
class MihEvent_EntryStart : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const MihEvent_EntryStart& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MihEvent_EntryStart&);

  public:
    MihEvent_EntryStart(const char *name=nullptr, short kind=0);
    MihEvent_EntryStart(const MihEvent_EntryStart& other);
    virtual ~MihEvent_EntryStart();
    MihEvent_EntryStart& operator=(const MihEvent_EntryStart& other);
    virtual MihEvent_EntryStart *dup() const override {return new MihEvent_EntryStart(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MihEvent_EntryStart& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MihEvent_EntryStart& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mih.msg:21</tt> by nedtool.
 * <pre>
 * // used to report that L2 entry finished
 * packet MihEvent_EntryEnd
 * {
 * }
 * </pre>
 */
class MihEvent_EntryEnd : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const MihEvent_EntryEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MihEvent_EntryEnd&);

  public:
    MihEvent_EntryEnd(const char *name=nullptr, short kind=0);
    MihEvent_EntryEnd(const MihEvent_EntryEnd& other);
    virtual ~MihEvent_EntryEnd();
    MihEvent_EntryEnd& operator=(const MihEvent_EntryEnd& other);
    virtual MihEvent_EntryEnd *dup() const override {return new MihEvent_EntryEnd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MihEvent_EntryEnd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MihEvent_EntryEnd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mih.msg:26</tt> by nedtool.
 * <pre>
 * // used to report that L2 handover started
 * packet MihEvent_HandoverStart
 * {
 *     int targetBS;
 * }
 * </pre>
 */
class MihEvent_HandoverStart : public ::omnetpp::cPacket
{
  protected:
    int targetBS;

  private:
    void copy(const MihEvent_HandoverStart& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MihEvent_HandoverStart&);

  public:
    MihEvent_HandoverStart(const char *name=nullptr, short kind=0);
    MihEvent_HandoverStart(const MihEvent_HandoverStart& other);
    virtual ~MihEvent_HandoverStart();
    MihEvent_HandoverStart& operator=(const MihEvent_HandoverStart& other);
    virtual MihEvent_HandoverStart *dup() const override {return new MihEvent_HandoverStart(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getTargetBS() const;
    virtual void setTargetBS(int targetBS);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MihEvent_HandoverStart& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MihEvent_HandoverStart& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mih.msg:32</tt> by nedtool.
 * <pre>
 * // used to report by WMaxPhySS to WMaxCtrlSS that HO-IND was actually transmitted
 * packet MihEvent_HandoverEnd
 * {
 * }
 * </pre>
 */
class MihEvent_HandoverEnd : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const MihEvent_HandoverEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MihEvent_HandoverEnd&);

  public:
    MihEvent_HandoverEnd(const char *name=nullptr, short kind=0);
    MihEvent_HandoverEnd(const MihEvent_HandoverEnd& other);
    virtual ~MihEvent_HandoverEnd();
    MihEvent_HandoverEnd& operator=(const MihEvent_HandoverEnd& other);
    virtual MihEvent_HandoverEnd *dup() const override {return new MihEvent_HandoverEnd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MihEvent_HandoverEnd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MihEvent_HandoverEnd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mih.msg:37</tt> by nedtool.
 * <pre>
 * // used to report that L2 reentry started
 * packet MihEvent_ReentryStart
 * {
 * }
 * </pre>
 */
class MihEvent_ReentryStart : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const MihEvent_ReentryStart& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MihEvent_ReentryStart&);

  public:
    MihEvent_ReentryStart(const char *name=nullptr, short kind=0);
    MihEvent_ReentryStart(const MihEvent_ReentryStart& other);
    virtual ~MihEvent_ReentryStart();
    MihEvent_ReentryStart& operator=(const MihEvent_ReentryStart& other);
    virtual MihEvent_ReentryStart *dup() const override {return new MihEvent_ReentryStart(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MihEvent_ReentryStart& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MihEvent_ReentryStart& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mih.msg:42</tt> by nedtool.
 * <pre>
 * // used to report that L2 reentry finished
 * packet MihEvent_ReentryEnd
 * {
 * }
 * </pre>
 */
class MihEvent_ReentryEnd : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const MihEvent_ReentryEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MihEvent_ReentryEnd&);

  public:
    MihEvent_ReentryEnd(const char *name=nullptr, short kind=0);
    MihEvent_ReentryEnd(const MihEvent_ReentryEnd& other);
    virtual ~MihEvent_ReentryEnd();
    MihEvent_ReentryEnd& operator=(const MihEvent_ReentryEnd& other);
    virtual MihEvent_ReentryEnd *dup() const override {return new MihEvent_ReentryEnd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MihEvent_ReentryEnd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MihEvent_ReentryEnd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mih.msg:47</tt> by nedtool.
 * <pre>
 * // used to report that IPv6 address has been obtained
 * packet MihEvent_L3AddrConfigured
 * {
 *     IPv6Address Addr;
 *     bool RemoteAutoconf;
 * }
 * </pre>
 */
class MihEvent_L3AddrConfigured : public ::omnetpp::cPacket
{
  protected:
    IPv6Address Addr;
    bool RemoteAutoconf;

  private:
    void copy(const MihEvent_L3AddrConfigured& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MihEvent_L3AddrConfigured&);

  public:
    MihEvent_L3AddrConfigured(const char *name=nullptr, short kind=0);
    MihEvent_L3AddrConfigured(const MihEvent_L3AddrConfigured& other);
    virtual ~MihEvent_L3AddrConfigured();
    MihEvent_L3AddrConfigured& operator=(const MihEvent_L3AddrConfigured& other);
    virtual MihEvent_L3AddrConfigured *dup() const override {return new MihEvent_L3AddrConfigured(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual IPv6Address& getAddr();
    virtual const IPv6Address& getAddr() const {return const_cast<MihEvent_L3AddrConfigured*>(this)->getAddr();}
    virtual void setAddr(const IPv6Address& Addr);
    virtual bool getRemoteAutoconf() const;
    virtual void setRemoteAutoconf(bool RemoteAutoconf);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MihEvent_L3AddrConfigured& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MihEvent_L3AddrConfigured& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mih.msg:53</tt> by nedtool.
 * <pre>
 * packet MihEvent_L3RoutingConfigured
 * {
 * }
 * </pre>
 */
class MihEvent_L3RoutingConfigured : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const MihEvent_L3RoutingConfigured& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MihEvent_L3RoutingConfigured&);

  public:
    MihEvent_L3RoutingConfigured(const char *name=nullptr, short kind=0);
    MihEvent_L3RoutingConfigured(const MihEvent_L3RoutingConfigured& other);
    virtual ~MihEvent_L3RoutingConfigured();
    MihEvent_L3RoutingConfigured& operator=(const MihEvent_L3RoutingConfigured& other);
    virtual MihEvent_L3RoutingConfigured *dup() const override {return new MihEvent_L3RoutingConfigured(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MihEvent_L3RoutingConfigured& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MihEvent_L3RoutingConfigured& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mih.msg:58</tt> by nedtool.
 * <pre>
 * // support for this is not implemented yet
 * packet MihEvent_L3LocationUpdated
 * {
 * }
 * </pre>
 */
class MihEvent_L3LocationUpdated : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const MihEvent_L3LocationUpdated& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MihEvent_L3LocationUpdated&);

  public:
    MihEvent_L3LocationUpdated(const char *name=nullptr, short kind=0);
    MihEvent_L3LocationUpdated(const MihEvent_L3LocationUpdated& other);
    virtual ~MihEvent_L3LocationUpdated();
    MihEvent_L3LocationUpdated& operator=(const MihEvent_L3LocationUpdated& other);
    virtual MihEvent_L3LocationUpdated *dup() const override {return new MihEvent_L3LocationUpdated(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MihEvent_L3LocationUpdated& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MihEvent_L3LocationUpdated& obj) {obj.parsimUnpack(b);}


#endif // ifndef __MIH_M_H

